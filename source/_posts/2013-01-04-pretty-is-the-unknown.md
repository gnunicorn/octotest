---
layout: post
title: "Pretty is the unknown"
tagline: "The systematical Problem with the new"
description: "
New is always better. Because New widens our view. It opens a range of new possibilities. New allows us to do things we didn't even dream of before. Or make them at least accessible by making it easier for us to do them. Therefore every new technology is better by definition. Or is it?"
category: 
tags: ["thoughts", "programming", "frameworks"]
---
{% include JB/setup %}

New is always better. Because New widens our view. It opens a range of new possibilities. New allows us to do things we didn't even dream of before. Or make them at least accessible by making it easier for us to do them. Therefore every new technology is better by definition. Or is it?

In the last years the hello-world-testcase has become a standard tutorial for every new technology introduced. Although many go beyond the simple task of showing a "hello world" text and try to demonstrate at least parts of the power this language or framework brings along. As such many take the tutorial further than that and show a "real world case" (as they call it). The Todo-List-App has become a common case here. And though even with that simple case, some frameworks already fall short, an inexperienced newcomer isn't able to see that.

As a being software developer for many years now, I went through many languages and frameworks. And let me tell you one thing: there is at least one field they fall short in. When they offer glue magic (like sqlalchemy), they'll fail on you when you need to debug or extend them. When they abstract backends by generalise their behaviour, you'll run into problems in performance and use the features offered by your backend. With every framework or technology you introduce their is a trade-off. And those easy-to-use-tutorials make the best to hide them from you. 

That is why they are pretty. You've not seen them in daily tasks, without make up, with ugly hair and under the steam pressure of your real time machine use case. And that sure doesn't look that nice, but after all, we are engineers and that is what we need: something that performs, delivers and runs stable. But that is barely the focus of framework tutorials. 

I wish there were less Evangalists and more Realists out there, not only being forcefully on what their language/framework/project can do but also what the trade-offs are and what it isn't suited to do. Because often before you figure those out, you are tied to it so heavily, that replacing it breaks your whole system and you are stuck with a bad solution, you'll just complain about anyways. 